#!/usr/bin/env bash

source bin/.bashrc
[[ $# -ne 1 ]] && label "Usage: $0 <type>" ko && exit 1

curr_version() {
    local version="$(git describe --abbrev=0 --tags)" && [[ ${version} == v* ]] && version=${version:1}
    echo "${version}"
}

next_version() {
    local version=${1:?missing version} && [[ ${version} == v* ]] && version=${version:1}
    local parts=(${version//./ })
    [[ ${#parts[@]} -ne 3 ]] && echo "Invalid version" && exit 1
    case $2 in
    major) ((++parts[0])); parts[1]=0; parts[2]=0;;
    minor) ((++parts[1])); parts[2]=0;;
    patch) ((++parts[2]));;
    esac
    echo "${parts[0]}.${parts[1]}.${parts[2]}"
}

branch_alias() {
    local version=${1:?missing version} && [[ ${version} == v* ]] && version=${version:1}
    local parts=(${version//./ })
    [[ ${#parts[@]} -ne 3 ]] && echo "Invalid version" && exit 1
    echo "${parts[0]}.${parts[1]}"
}

release_branches() {
    local branches="$(git branch --remote --list "origin/[0-9].[0-9]")"
    echo "${branches:-origin/master}"
}

checkout() {
    local branch=${1:?missing branch}
    local parts=(${branch//// })
    [[ ${#parts[@]} -ne 2 ]] && echo "Invalid branch" && exit 1
    git checkout --quiet -B "${parts[1]}" "${parts[0]}/${parts[1]}" && \
    git pull --quiet "${parts[0]}" "${parts[1]}"
}

tag() {
    local version=${1:?missing version} && [[ ${version} == v* ]] && version=${version:1}
    git tag -sm enjoy "v${version}"
}

changelog() {
    local branch=${1:?missing branch}
    local since_version=${2:?missing since version} && [[ ${since_version} == v* ]] && since_version=${since_version:1}
    local next_version=${3:?missing next version} && [[ ${next_version} == v* ]] && next_version=${next_version:1}
    local filename="CHANGELOG-"$(branch_alias "${next_version}")".md"

    [[ ! -d "var/cache/changelog/${branch}" ]] && mkdir -p "var/cache/changelog/${branch}"
    [[ -d ../../var/cache/changelog ]] && cp -R ../../var/cache/changelog var/cache/

    for package in $(packages); do
        name="$(package_name "${package}")"
        file="$(dirname "${package}")/${filename}"
        [[ ! -f "${file}" ]] && echo "# Changelog" >> "${file}"
        rm -f "${file}.tmp" && \
        ../../bin/github-changelog-generator -u msgphp -p msgphp -t "${GITHUB_TOKEN}" \
            --cache-file "var/cache/changelog/${branch}" \
            --output "${file}.tmp" \
            --since-tag "v${since_version}" \
            --future-release "v${next_version}" \
            --release-branch "${branch}" \
            --release-url "https://github.com/msgphp/${name}/tree/%s" \
            --include-labels "${name/-/,}" \
            --simple-list \
            --header-label "" \
            --no-issues \
            --no-filter-by-milestone \
            --no-author \
            --no-compare-link \
            --no-verbose >/dev/null && \
        sed -e '/^\\\* \*This Change Log was automatically generated .*/d' -i "${file}.tmp" && \
        sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba' -i "${file}.tmp" && \
        sed -e '1 a \\n' -i "${file}" && \
        sed -e "2 r ${file}.tmp" -i "${file}" && \
        sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba' -i "${file}" && \
        rm -f "${file}.tmp" && \
        git add "${file}"
        [[ $? -ne 0 ]] && return 1
    done

    cp -R var/cache/changelog ../../var/cache/
    git commit --quiet -m "update changelog to ${next_version}"
}

bump() {
    local branch=${1:?missing branch}
    mv .lando.yml .lando.yml.tmp && \
    run_in_package composer config "extra.branch-alias.dev-master" "${branch}-dev" && \
    mv .lando.yml.tmp .lando.yml && \
    git add src/*/composer.json && \
    git commit --quiet -m "bumped branch alias to ${branch}"
}

assert_clean
load_env

confirm "Run smoke test first?" yes
if [[ $? -eq 1 ]]; then
    bin/smoke-test
    [[ $? -ne 0 ]] && label "Failed" ko && exit 1
fi

confirm "Build docs?" yes
if [[ $? -eq 1 ]]; then
    bin/build-docs && assert_clean
    [[ $? -ne 0 ]] && label "Failed" ko && exit 1
fi

label "Synchronizing source"
git_sync var/release "${SRC_REPO}"
[[ $? -ne 0 ]] && label "Failed" ko && exit 1

confirm "Release?"
[[ $? -ne 1 ]] && label "Aborted" ok && exit 0

pushd var/release &> /dev/null
restore() {
    popd &> /dev/null
}

case $1 in
major|minor)
    curr_version="$(curr_version)"
    next_version="$(next_version "${curr_version}" "$1")"
    branch="$(branch_alias "${next_version}")"
    label "Releasing ${curr_version} -> ${next_version}"
    changelog "$(git rev-parse --abbrev-ref HEAD)" "${curr_version}" "${next_version}" && \
    bump "${branch}"
    [[ $? -ne 0 ]] && label "Failed" ko && restore && exit 1
    confirm "Create release branch ${branch}?" yes
    if [[ $? -eq 1 ]]; then
        git checkout --quiet -b "${branch}" && \
        tag "${next_version}" && \
        git checkout --quiet master && \
        bump "$(branch_alias "$(next_version "${next_version}" minor)")"
    else
        tag "${next_version}"
    fi
    [[ $? -ne 0 ]] && label "Failed" ko && restore && exit 1
    label "Done" ok
    ;;
patch)
    for branch in $(release_branches); do
        checkout "${branch}"
        [[ $? -ne 0 ]] && label "Failed" ko && restore && exit 1
        curr_version="$(curr_version)"
        next_version="$(next_version "${curr_version}" patch)"
        label "Releasing ${curr_version} -> ${next_version}"
        changelog "$(git rev-parse --abbrev-ref HEAD)" "${curr_version}" "${next_version}" && \
        tag "${next_version}"
        [[ $? -ne 0 ]] && label "Failed" ko && restore && exit 1
        label "Done" ok
    done;
    ;;
esac

restore
